# We aren't declaring django models here, we will declare simple classes that will# act as a modelimport randomimport stringimport loggingfrom api.mongoconn import MongoConnectionclass Visitor:    COLLECTION = MongoConnection.Collections.VISITOR    class Meta:        ID_KEY = 'visitorId'        USER_ID_KEY = 'userId'        SELECTED_CHALLENGE_KEY = 'selectedChallenge'    def __init__(self, visitor_id=None, user_id=None, selected_challenge_id=None):        """        This method instantiates a visitor object by taking visitor_id and        user_id as optional param        """        self.visitor_id = visitor_id        self.user_id = user_id        self.selected_challenge_id = selected_challenge_id        self.cached_submissions = None    def save(self):        """        This method saves the visitor model to the database        If the visitor id exists in the database updates the existing record        Else the new visitor is saved        """        visitorCollection = MongoConnection().get_collection(self.COLLECTION)        visitorCollection.replace_one({self.Meta.USER_ID_KEY: self.user_id},                                      self.to_json(),                                      upsert=True)    def select_challenge(self, challenge_id):        """        selects a new challenge for a given user        """        self.selected_challenge_id = challenge_id        self.save()    def save_submission(self, question_id, variables, facets):        """        saves the submission for a given question        :param question_id: the question that is to be submitted        :param variables: the list of variables that have been submitted        :param facets: the list of facets that have been submitted        :return:        """        question = Question(visitor_id = self.visitor_id, question_id = question_id, variables = variables, facets = facets)        question.save()    def get_answered_variables(self, reload=False):        return self._get_combined_propert('variables', reload)    def get_selected_facets(self, reload = False):        return self._get_combined_propert('facets', reload)    def _get_combined_propert(self, property_name, reload):        if self.cached_submissions is None or reload == True:            self.__get_submissions()        ret_values = {}        for submission in self.cached_submissions:            ret_values.update(getattr(submission, property_name))        return ret_values    def __get_submissions(self):        self.cached_submissions = Question.get_submissions_for(visitor_id=self.visitor_id)    def to_json(self):        """        converts the object to mongo representation.        """        return {self.Meta.ID_KEY: self.visitor_id,                self.Meta.USER_ID_KEY: self.user_id,                self.Meta.SELECTED_CHALLENGE_KEY: self.selected_challenge_id}    @classmethod    def create(cls, user_id):        """        creates a visitor with provided user id and random visitor id        """        return Visitor(user_id=user_id, visitor_id=Visitor.__generate_random_id())    @classmethod    def get_by_user_id(cls, user_id):        """        returns the visitor with a specific user id        """        return cls.__get_visitor_with({cls.Meta.USER_ID_KEY: user_id})    @classmethod    def get_by_visitor_id(cls, visitor_id):        """        returns the visitor with a particular id        """        return cls.__get_visitor_with({cls.Meta.ID_KEY: visitor_id});    @classmethod    def __get_visitor_with(cls, filter):        """        internal method that matches finds a matching record based on the filter.        the filter could be any object type filter        Parameters:        filter - object            The filter that should be used to select from the visitor collection        """        visitor = MongoConnection().get_collection(cls.COLLECTION).find_one(filter)        if visitor is None:            logging.info('Couldn\'t find record with filter ')            return None        logging.info('Match found')        return Visitor(visitor_id=visitor[cls.Meta.ID_KEY],                       user_id=visitor[cls.Meta.USER_ID_KEY],                       selected_challenge_id=visitor[cls.Meta.SELECTED_CHALLENGE_KEY])    @staticmethod    def __generate_random_id(size=40, chars=string.ascii_uppercase + string.digits):        """        This method generates a unique id string of size with chars.        From: http://stackoverflow.com/questions/12179271/python-classmethod-and-staticmethod-for-beginner        Parameters:        -----------        size - int            The size of the string to be returned        chars - char array            The string containing the list of valid characters to include        """        return ''.join(random.SystemRandom().choice(chars) for _ in range(size))class Error:    class Meta:        ERROR_KEY = 'errorDescription'    def __init__(self, error_description=''):        """        Initializes an error object        """        self.error_description = error_description    def to_json(self):        return {self.Meta.ERROR_KEY: self.error_description}class SlapResponse:    class Meta:        ID_KEY = 'visitorId'        ITEMS_KEY = 'items'        QUESTIONS_KEY = 'questions'    def __init__(self, visitor, questions=None, items=None):        """        """        self.visitor = visitor        self.questions = questions        self.items = items    def set_questions(self, questions):        self.questions = questions    def set_items(self, items):        self.items = items    def to_json(self):        ret_val = {self.Meta.ID_KEY: self.visitor.visitor_id}        if self.items != None:            ret_val[self.Meta.ITEMS_KEY] = self.items        if self.questions != None:            ret_val[self.Meta.QUESTIONS_KEY] = self.questions        return ret_valclass Question:    COLLECTION = MongoConnection.Collections.QUESTION    class Meta:        VISITOR_ID_KEY = 'visitorId'        QUESTION_ID_KEY = 'questionId'        IS_OVERWRITTEN_KEY = 'isOverwritten'        FACETS_KEY = 'facets'        VARIABLES_KEY = 'variables'    def __init__(self, id = None, variables = {}, facets = {}, is_overwritten = False, visitor_id = None, question_id = None):        self.id = id        self.variables = variables        self.facets = facets        self.is_overwritten = is_overwritten        self.visitor_id = visitor_id        self.question_id = question_id    def save(self):        """        saves the given question in persistence        :return:        """        questionCollection = MongoConnection().get_collection(self.COLLECTION)        questionCollection.insert_one(self.to_json())    def to_json(self):        """        :rtype: Dictionary        :return:        """        Meta = self.Meta        return { Meta.VARIABLES_KEY : self.variables,                 Meta.FACETS_KEY : self.facets,                 Meta.IS_OVERWRITTEN_KEY : self.is_overwritten,                 Meta.VISITOR_ID_KEY : self.visitor_id,                 Meta.QUESTION_ID_KEY : self.question_id }    @staticmethod    def get_submissions_for(visitor_id, question_id = None, valid=True):        """        gets the list of submissions for any given visitor        :param visitor_id: the id of the visitor for which submissions are to be fetched        :param question_id: the submissions for a specific question that is to be retrieved. Not passing will fetch it for all questions        :param valid: if set gets all the submissions that haven't been overwritten i.e. haven't been resubmitted.        :return:        """        Meta = Question.Meta        query = {Question.Meta.VISITOR_ID_KEY: visitor_id,                 Question.Meta.IS_OVERWRITTEN_KEY: not valid}        if question_id is not None:            query[Question.Meta.QUESTION_ID_KEY] = question_id        submissions = MongoConnection().get_collection(Question.COLLECTION).find(query)        return_values = []        for submission in submissions:            return_values.append(Question(                    id = submission['_id'],                    variables = submission[Meta.VARIABLES_KEY],                    facets = submission[Meta.FACETS_KEY],                    is_overwritten = submission[Meta.IS_OVERWRITTEN_KEY],                    visitor_id = submission[Meta.VISITOR_ID_KEY],                    question_id = submission[Meta.QUESTION_ID_KEY]            ))        return return_values