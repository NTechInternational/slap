# We aren't declaring django models here, we will declare simple classes that will# act as a modelimport datetimeimport randomimport stringimport loggingfrom api.mongoconn import MongoConnectionclass Visitor:    COLLECTION = MongoConnection.Collections.VISITOR    class Meta:        ID_KEY = 'visitorId'        USER_ID_KEY = 'userId'        SELECTED_CHALLENGE_KEY = 'selectedChallenge'    def __init__(self, visitor_id=None, user_id=None, selected_challenge_id=None):        """        This method instantiates a visitor object by taking visitor_id and        user_id as optional param        """        self.visitor_id = visitor_id        self.user_id = user_id        self.selected_challenge_id = selected_challenge_id        self.cached_submissions = []    def save(self):        """        This method saves the visitor model to the database        If the visitor id exists in the database updates the existing record        Else the new visitor is saved        """        visitor_collection = MongoConnection().get_collection(self.COLLECTION)        visitor_collection.replace_one({self.Meta.USER_ID_KEY: self.user_id},                                      self.to_json(),                                      upsert=True)    def select_challenge(self, challenge_id):        """        selects a new challenge for a given user        """        self.selected_challenge_id = challenge_id        self.save()    def save_submission(self, question_id, variables, facets):        """        saves the submission for a given question        :param question_id: the question that is to be submitted        :param variables: the list of variables that have been submitted        :param facets: the list of facets that have been submitted        :return:        """        question = Question(visitor_id = self.visitor_id, question_id = question_id, variables = variables, facets = facets)        question.save()    def reset_session(self):        """        Saves the current session into start over session and resets the session        :return:        """        self._store_session('', False)    def save_session(self, final_text):        self._store_session(final_text, True)    def _store_session(self,final_text, is_completed):        """        :param is_reset:        :return:        """        VisitorSessionInfo(self, Question.get_submissions_for(self.visitor_id), final_text).save(is_completed)        InteractionLog.clear_log(self.visitor_id)        self.select_challenge(None)    def get_answered_variables(self, reload=False):        return self._get_combined_propert('variables', reload)    def get_selected_facets(self, reload = False):        return self._get_combined_propert('facets', reload)    def _get_combined_propert(self, property_name, reload):        if self.cached_submissions is None or reload == True:            self.__get_submissions()        ret_values = {}        for submission in self.cached_submissions:            ret_values.update(getattr(submission, property_name))        return ret_values    def __get_submissions(self):        self.cached_submissions = Question.get_submissions_for(visitor_id=self.visitor_id)    def to_json(self):        """        converts the object to mongo representation.        """        return {self.Meta.ID_KEY: self.visitor_id,                self.Meta.USER_ID_KEY: self.user_id,                self.Meta.SELECTED_CHALLENGE_KEY: self.selected_challenge_id}    @classmethod    def create(cls, user_id):        """        creates a visitor with provided user id and random visitor id        """        return Visitor(user_id=user_id, visitor_id=Visitor.__generate_random_id())    @classmethod    def get_by_user_id(cls, user_id):        """        returns the visitor with a specific user id        """        return cls.__get_visitor_with({cls.Meta.USER_ID_KEY: user_id})    @classmethod    def get_by_visitor_id(cls, visitor_id):        """        returns the visitor with a particular id        """        return cls.__get_visitor_with({cls.Meta.ID_KEY: visitor_id});    @classmethod    def __get_visitor_with(cls, filter):        """        internal method that matches finds a matching record based on the filter.        the filter could be any object type filter        Parameters:        filter - object            The filter that should be used to select from the visitor collection        """        visitor = MongoConnection().get_collection(cls.COLLECTION).find_one(filter)        if visitor is None:            logging.info('Couldn\'t find record with filter ')            return None        logging.info('Match found')        return Visitor(visitor_id=visitor[cls.Meta.ID_KEY],                       user_id=visitor[cls.Meta.USER_ID_KEY],                       selected_challenge_id=visitor[cls.Meta.SELECTED_CHALLENGE_KEY])    @staticmethod    def __generate_random_id(size=40, chars=string.ascii_uppercase + string.digits):        """        This method generates a unique id string of size with chars.        From: http://stackoverflow.com/questions/12179271/python-classmethod-and-staticmethod-for-beginner        Parameters:        -----------        size - int            The size of the string to be returned        chars - char array            The string containing the list of valid characters to include        """        return ''.join(random.SystemRandom().choice(chars) for _ in range(size))    def delete_submission(self, question_id):        Question.remove(self.visitor_id, question_id)class Error:    class Meta:        ERROR_KEY = 'errorDescription'    def __init__(self, error_description=''):        """        Initializes an error object        """        self.error_description = error_description    def to_json(self):        return {self.Meta.ERROR_KEY: self.error_description}class SlapResponse:    class Meta:        ID_KEY = 'visitorId'        ITEMS_KEY = 'items'        QUESTIONS_KEY = 'questions'    def __init__(self, visitor, questions=None, items=None):        """        """        self.visitor = visitor        self.questions = questions        self.items = items    def set_questions(self, questions):        self.questions = questions    def set_items(self, items):        self.items = items    def to_json(self):        ret_val = {self.Meta.ID_KEY: self.visitor.visitor_id}        if self.items != None:            ret_val[self.Meta.ITEMS_KEY] = self.items        if self.questions != None:            ret_val[self.Meta.QUESTIONS_KEY] = self.questions        return ret_valclass Question:    COLLECTION = MongoConnection.Collections.QUESTION    class Meta:        VISITOR_ID_KEY = 'visitorId'        QUESTION_ID_KEY = 'questionId'        FACETS_KEY = 'facets'        VARIABLES_KEY = 'variables'    def __init__(self, id = None, variables = {}, facets = {}, is_overwritten = False, visitor_id = None, question_id = None):        self.id = id        self.variables = variables        self.facets = facets        self.visitor_id = visitor_id        self.question_id = question_id    def save(self):        """        saves the given question in persistence        :return:        """        Meta = self.Meta        question_collection = MongoConnection().get_collection(self.COLLECTION)        question_collection.replace_one({Meta.VISITOR_ID_KEY : self.visitor_id,                                         Meta.QUESTION_ID_KEY : self.question_id }, self.to_json(), upsert = True)    def to_json(self):        """        :rtype: Dictionary        :return:        """        Meta = self.Meta        return { Meta.VARIABLES_KEY : self.variables,                 Meta.FACETS_KEY : self.facets,                 Meta.VISITOR_ID_KEY : self.visitor_id,                 Meta.QUESTION_ID_KEY : self.question_id }    @staticmethod    def get_submissions_for(visitor_id, question_id = None):        """        gets the list of submissions for any given visitor        :param visitor_id: the id of the visitor for which submissions are to be fetched        :param question_id: the submissions for a specific question that is to be retrieved. Not passing will fetch it for all questions        :param valid: if set gets all the submissions that haven't been overwritten i.e. haven't been resubmitted.        :return:        """        Meta = Question.Meta        query = {Question.Meta.VISITOR_ID_KEY: visitor_id}        if question_id is not None:            query[Question.Meta.QUESTION_ID_KEY] = question_id        submissions = MongoConnection().get_collection(Question.COLLECTION).find(query)        return_values = []        for submission in submissions:            return_values.append(Question(                    id = submission['_id'],                    variables = submission[Meta.VARIABLES_KEY],                    facets = submission[Meta.FACETS_KEY],                    visitor_id = submission[Meta.VISITOR_ID_KEY],                    question_id = submission[Meta.QUESTION_ID_KEY]            ))        return return_values    @staticmethod    def remove(visitor_id, question_id):        MongoConnection().get_collection(Question.COLLECTION).remove({Question.Meta.QUESTION_ID_KEY : question_id,                                                                    Question.Meta.VISITOR_ID_KEY : visitor_id})class VisitorSessionInfo:    """    Represents the data that will be persisted for a given user    """    COLLECTION = MongoConnection.Collections.VISITOR_SESSION    COLLECTION_UNFINISHED = MongoConnection.Collections.VISITOR_SESSION_START_OVER    class Meta:        QUESTIONS_KEY = 'questions'        FINAL_TEXT_KEY = 'finaltext'        COMPLETED_ON_KEY = 'sessionCompletedOn'    def __init__(self, visitor, submitted_question, final_text = ''):        """        :param visitor: the visitor, whose session this represents        :param submitted_question: the list of submissions that have already been made for a session        :param final_text: the final text / answer provided by the user when saving the session        :return:        """        self.visitor = visitor        self.submitted_questions = submitted_question        self.final_text = final_text    def save(self, is_completed):        """        Saves the Visitor Session Information to the database        :param is_completed: indicates whether the session was completed or not, based upon which the collection is selected        :return:        """        # Note: we are using the visitor information as the base for the storing the session info.        # We will be adding other properties to it such as questions answered, final text provided        object_to_persist = self.to_json()        collection_to_persist = self.COLLECTION if is_completed else self.COLLECTION_UNFINISHED        session_collection = MongoConnection().get_collection(collection_to_persist)        session_collection.insert_one(object_to_persist)    def to_json(self):        """        Converts the session information to json/bson so that it can be sent to client or persisted in db        :return:        """        json = self.visitor.to_json()        # Format the questions so that we remove duplicate info i.e. visitor information and store them        question_to_persist = []        for question in self.submitted_questions:            question_json = question.to_json()            del question_json[Question.Meta.VISITOR_ID_KEY] # remove visitor_id key, since we have it in main object            question_to_persist.append(question_json)        # Set the questions, final text and completed key        json[self.Meta.QUESTIONS_KEY] = question_to_persist        json[self.Meta.FINAL_TEXT_KEY] = self.final_text        json[self.Meta.COMPLETED_ON_KEY] = datetime.datetime.now().isoformat()        return jsonclass InteractionLog:    """    This object will be used to store individual interactions done by the user. This will act as    a journal so that we can support undo interactions.    Note: We are storing the interaction log for the whole session in a single document. This might be an issue    if there is too much interaction and the size of the document gets too large. So, interaction log can be    a possible optimization based on how the user interacts.    """    COLLECTION = MongoConnection.Collections.INTERACTION_LOG    class Meta:        INTERACTION_TYPE_KEY = 'type'        OLD_VALUE_KEY = 'oldvalue'        VISITOR_KEY = 'visitorId'        LOG_KEY = 'log'        INTERACTION_ON = 'interactionOn'    def __init__(self, visitor_id, logs, id = None):        self.visitor_id = visitor_id        self.logs = logs        self._id = id    def push(self, interaction_type, old_value, collection = None):        """        adds a new interaction log for the visitor        :param interaction_type:        :param old_value:        :param collection:        :return:        """        if collection is None:            collection = self.get_collection()        self.logs.append({self.Meta.INTERACTION_TYPE_KEY : interaction_type,                         self.Meta.OLD_VALUE_KEY : old_value,                         self.Meta.INTERACTION_ON : datetime.datetime.now().isoformat()})        self.save(collection)    def pop(self, collection=None):        """        removes the last log for the visitor and returns it.        :param visitor_id:        :param collection        :return:        """        if collection is None:            collection = InteractionLog.get_collection()        last_interaction = None        if len(self.logs) > 0:            last_interaction = self.logs.pop()            self.save(collection) # if we have popped on interaction save it.        return last_interaction    def to_json(self):        """        :return:        """        return {self.Meta.VISITOR_KEY : self.visitor_id,                self.Meta.LOG_KEY : self.logs}    def save(self, collection):        """        :param visitor_id:        :param collection:        :return:        """        Meta = InteractionLog.Meta        query = {Meta.VISITOR_KEY : self.visitor_id}        collection.replace_one(query, self.to_json(), upsert=True)    @staticmethod    def get_collection():        return MongoConnection().get_collection(collection_name=InteractionLog.COLLECTION)    @staticmethod    def get_interaction(visitor_id, collection):        Meta = InteractionLog.Meta        query = {Meta.VISITOR_KEY : visitor_id}        result = collection.find_one(query)        log = None        if result is None:            log = InteractionLog(visitor_id, [])        else:            log = InteractionLog(visitor_id, result[Meta.LOG_KEY])        return log    @staticmethod    def clear_log(visitor_id):        collection = InteractionLog.get_collection()        collection.remove({InteractionLog.Meta.VISITOR_KEY : visitor_id })